---
title: 二进制
date: 2020-04-17 09:50:47
tags:
- 二进制
---

##### 前言：

   bit(位)：数据存储的最小单元。在计算机二进制系统中，位，简记为b，也称为比特(bit)，每个二进制数字0或1就是一个位(bit)，其中每 8bit = 1 byte(字节)；

   Java中的int数据类型占4个byte(字节)，而1 byte(字节) = 8 bit(位)；（说白了，在二进制系统中是以bit 作为数据存储单元的）


##### 无符号数和有符号数

 在计算器中参与运算的数有两大类：无符号数和有符号数

     (1)有符号数：
      对于有符号数而言，符号的正、负机器是无法识别的，但由于“正、负”恰好是两种截然不同的状态，如果用“0”表示“正”，用“1”表示“符”，这样符号也被数字化了，
      并且规定将它放在有效数字的前面，即组成了有符号数。所以，在二进制中使用最高位（第一位）来表示符号，最高位是0，表示正数；最高位是1，表示负数。

     (2)无符号数：
      无符号数是针对二进制来讲的，无符号数的表数范围是非负数。全部二进制均代表数值（所有位都用于表示数的大小），没有符号位。即第一个"0"或"1"不表示


 例子：

    (1)在Java中int数据类型是怎么在计算机中表示的呢？

     假设 int  number = 1 ,那么number在计算机系统中将表示如下（32bit）：

     00000000  00000000  00000000  00000001

     同理可得，number=-1 时，在二进制中表示如下：

     10000000  00000000  00000000  00000001

     注意：最高位（第一位）是符号位，因为是number值为1是一个正数，所以最高位为0；

 

    (2)二进制转十进制？

     要从右到左用二进制的每个数去乘以2的相应次方（次方要从0开始算起）；

     假如：二进制数1101转化成十进制 ，那么 1101 = 1*2^0+0*2^1+1*2^2+1*2^3 = 1+0+4+8 = 13；

     注意：任何数的0次方都是1。

#####  二进制中的原码、反码、补码

    在计算机内，定点数有3种表示法：原码、反码和补码
    原码：就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。
    反码：表示法规定：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。
    补码：表示法规定：正数的补码与其原码相同；负数的补码是在其反码的末位加1。

  对于有符号数而言：

      (1)二进制的最高位是符号位：0表示正数，1表示负数

      (2)正数的原码、反码、补码都一样；

      (3)负数的反码 =  它的原码符号位不变，其他位取反（0 ->1 ; 1->0 ）；

      (4)负数的补码 = 它的反码 +1；

      (5)0的反码、补码都是0；

      (6)在计算机运算的时候，都是以补码的方式来运算的；


##### 负数的二进制
负数的原码 = （十进制的相反数），按位取反， 然后 + 1；
负数的反码 =  它的原码符号位不变，其他位取反（0 ->1 ; 1->0 ）
负数的补码 = 它的反码 +1；

例如：-7的二进制等于7的二进制按位取反，然后+1

下面以8位为例：

第一步：

　　7的二进制：0000 0111

第二步：

　　7的二进制（取反）：1111 1000

第三步：

　　取反后加1：11111001

所以-7的二进制是：1111 1001

 

那么怎么求一个二进制负数的十进制数？把上面的步骤反过来就是了

一个负数：11111001

第一步：

　　减一：11111000

第二步：

　　按位取反：00000111

第三步：

　　计算然后取相反数：-(1*2^2 + 1*2^1 + 1*2^0) = -7

计算结果是-7，

那么这个二进制数的十进制就是：-7


##### 八进制、十六进制、十进制、二进制

十进制负数转八进制、十六进制

负数转换成八进制、十六进制，只需在补码(二进制)的基础上，3位合成一位计算，或者4位合成一位计算

-3的转换成二进制为：

1111 1111 1111 1111 1111 1111 1111 1101

八进制则将-3的二进制从右至左每3位为一个单元，不够三位用0补 即：

011 111 111 111 111 111 111 111 111 111 101
计算每一个单元，结果为：37777777775

十六进制则将-3的二进制从右至左每4位合并为一个单元，即：

1111 1111 1111 1111 1111 1111 1111 1101
计算后为： FFFFFFFD

转换十进制-3为八进制和十六进制

十六进制（0，1，2，3，4，5，6，7，8，9，A，B，C，D，F）


#####  &gt;&gt;,&lt;&lt;,&gt;&gt;&gt;移位运算

###### **1、&lt;&lt;** 

有符号左移位，将运算数的二进制整体左移指定位数，低位用0补齐。

正数：5&lt;&lt;2

1、转化为二进制：

0000 0000 0000 0000 0000 0000 0000 0101

2、整体左移指2位数

0000 0000 0000 0000 0000 0000 0001 0100

3、转化为十进制

1*2^4+1*2^2=16+4=20

M<<N相当于M*2^n.

负数：-5<<2

1、转化为二进制：

1111 1111 1111 1111 1111 1111 1111 1011

2、整体左移指2位数

1111 1111 1111 1111 1111 1111 1110 1100

3、转化为十进制

-20

M<<N相当于M*2^n.

###### **2、&gt;&gt;**

&gt;&gt;有符号右移位，将运算数的二进制整体右移指定位数，正数高位用0补齐，负数高位用1补齐（保持负数符号不变）

正数：5>>2

1、转化为二进制：

0000 0000 0000 0000 0000 0000 0000 0101

2、整体右移指2位数

0000 0000 0000 0000 0000 0000 0000 0001

3、转化为十进制

1*2^0=1

M>>N相当于M/2^n 取商

负数：-5>>2

1、转化为二进制：

1111 1111 1111 1111 1111 1111 1111 1011

2、整体右移指2位数

1111 1111 1111 1111 1111 1111 1111 1110

3、转化为十进制

-2

M<<N相当于如果运算数是偶数，那么那么它的运算结果就是 x = -(|x| / 2)，如果运算数是奇数，那么它的运算结果就是 x = -(|x| / 2) - 1

###### **3、>>>**

&gt;&gt;&gt;无符号右移位，不管正数还是负数，高位都用0补齐（忽略符号位）

1、正数的>>>无符号右移位和>>有符号右移位计算结果相同

2、负数

-5>>>2

1、转化为二进制：

1111 1111 1111 1111 1111 1111 1111 1011

2、整体右移指2位数

0011 1111 1111 1111 1111 1111 1111 1110

3、转化为十进制

1073741822
